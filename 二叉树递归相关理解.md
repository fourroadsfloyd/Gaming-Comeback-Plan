# 二叉树中的dfs分析

1、必须存在终止条件：需要考虑终止条件有哪些

2、如何操作

------

## lc.226 翻转二叉树 

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    TreeNode* invertTree(TreeNode* root) {
        if (root == nullptr) return nullptr;
        if (root->left == nullptr && root->right == nullptr) {
            return root;
        }

        TreeNode *left = invertTree(root->left);
        TreeNode *right = invertTree(root->right);

        root->right = left;
        root->left = right;

        return root;
    }
};
```

终止条件：

​	1、当root为空时，直接返回nullptr。

​	2、当左结点和右结点都是空时，当前是叶子结点，不需要再对其递归，返回root

操作：

​	当前层调用递归，返回值是当前层root的左右结点。故调用递归后，再将左右结点交换，返回给上一层。

------

## lc.617 合并二叉树

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    TreeNode* mergeTrees(TreeNode* root1, TreeNode* root2) {
        if(root1==nullptr) return root2;
        if(root2==nullptr) return root1;

        TreeNode* m = new TreeNode(root1->val + root2->val);
        m->left = mergeTrees(root1->left, root2->left);
        m->right = mergeTrees(root1->right, root2->right);

        return m;
    }
};
```

终止条件：

​	1、当root1为空时，说明树1在该位置的结点不存在，直接使用树2在该位置的结点即可，return root2

​	2、当root2为空时，说明树2在该位置的结点不存在，直接使用树1在该位置的结点即可，return root1

操作：

​	1、将root1和root2的值相加，构造新的结点。

​	2、递归调用root1的left和root2的left，root1的right和root2的right，新构建的结点的left和right接收返回值

​	3、返回值就是新构造的结点

------

## lc.104 二叉树的最大深度

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    int maxDepth(TreeNode* root) {
        if(root==nullptr) return 0;

        return (std::max(maxDepth(root->left), maxDepth(root->right))+1);
    }
};
```

终止条件：

​	root为空时，return 0；当前root无深度

操作：

​	如果root不为空，即使root是叶子结点，当前root也占了一层深度。

​	但何时加上这个1呢？递归函数的终止条件返回0，当前层仅知道自己没有子结点，并没有加上自己这一层，	所以需要在返回值中+1。通过左右结点的层数取最大值，可以知道当前结点有多少层。

------

## lc.114 二叉树展开为链表--先序遍历

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    void flatten(TreeNode* root) 
    {
        //如果这里不判断，for循环中vec可能为空，报错。如果不想写，则需要for循环从1开始
        if(root == nullptr) return;	
        
        vector<TreeNode*> vec;
        preOrder(root, vec);

        for(int i=0;i<vec.size()-1;i++)
        {
            TreeNode* curr = vec[i];
            TreeNode* next = vec[i+1];

            curr->left = nullptr;
            curr->right = next;
        }    
    }

    void preOrder(TreeNode* root, vector<TreeNode*>& vec)
    {
        if(root == nullptr) return;

        vec.push_back(root);
        preOrder(root->left, vec);
        preOrder(root->right, vec);
    }
};
```

题解：

​	根据题目可知，将二叉树转成链表，且链表顺序是二叉树的先序遍历，且使用右结点构造链表，左结点为空。

​	怎样才能够使链表顺序为先序遍历呢？首先使用先序遍历存储结点，再将结点依次串起来即可。

------

## lc.538 将二叉搜索树转换为累加树

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    TreeNode* convertBST(TreeNode* root) {
        num = 0;
        helper(root);
        return root;
    }

    void helper(TreeNode* root)
    {
        if(root == nullptr) return;

        helper(root->right);
        num += root->val;
        root->val = num;
        helper(root->left);
    }

private:
    int num = 0;
};
```

题解：

​	首先，题目中说的是一个二叉搜索树中的某个结点的值需要是该值与所有大于等于该结点值的所有结点值之和，即**某个结点的新的本身的值=所有结点的值大于本身结点值的和+本身的值**。

​	对于二叉搜索树，结点的右子树总是大于等于该结点，故应从右子树开始遍历，依次累加并赋值。普通的中序遍历是左根右，但这里应该是右根左的顺序，依次累加。左子树也需要累加其根的值，因为题目条件要求**某个结点的新的本身的值=所有结点的值大于本身结点值的和+本身的值**。

![](./img/sum-tree.png)

​	**若是小于等于则是普通的中序遍历，左根右，依次累加。**

------

## lc.105 从前序与中序遍历序列构造二叉树 